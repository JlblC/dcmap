#pragma once
#ifndef G_VTID_H
#define G_VTID_H

#include "g_gsys.h"

#include "detail/g_vtid_source.h"

#include "g_hash_map.h"

namespace gsys
{
	namespace vtid
	{
	//	using namespace gsys;
	}

    inline char const* vtid_raw_type_name(type_info const& inf)
    {
    #ifdef _MSC_VER
		//return inf.raw_name();
		return inf.name();
    #else
		return inf.name();
    #endif
    }

	inline char const* vtid_type_name(type_info const& inf)
	{
		return inf.name();
	}

	template<class T> 
	char const* vtid_get_typename()
	{
		return gsys_typename<T>();
	}

	template<class T> 
	char const* vtid_get_typename_var(T const&)
	{
		return vtid_get_typename<T>();
	}

	namespace detail
	{
		class vtid_variable;
	}
	class vtid_ref;
	class vtid_var;
	class vtid_refvar;
	class vtid_member_ref;

	class vtid_t : noncopyable
	{
		friend class vtid_lib;
		friend class ::gsys::detail::vtid_variable;
		friend class vtid_var;
		friend class vtid_ref;
		friend class vtid_refvar;
		friend class vtid_member_ref;

		// autogenerated type name
		char const * czTypeName;

		int m_iAliasCount;
	private: // creation & destruction only by  vtid_lib class
		~vtid_t()
		{

		}
		vtid_t()
		{

		}
	protected:
		// interface for creation of object
		detail::vtid_class_factory_proc ClassFactory;
		detail::vtid_type_proc TypeProc;
		detail::vtid_access_var_proc AccessProc;
		detail::vtid_export_proc ExportProc;

		// common functions that can be used to 
		detail::vtid_operations BaseOp;

		detail::vtid_user_info  UserInf;

		// child declarations
		//typedef std::map<string,detail::vtid_decl> DeclMap;
		typedef strimultimap<string,detail::vtid_decl> DeclMap;
		// cast offset map
		typedef std::map<vtid_t const *,gsys_pt_diff> StaticCastMap;

		// parent info
		vtid_t const * ParentType;
		gsys_pt_diff iParentOffset;

		DeclMap m_mapDecl;

		StaticCastMap m_mapCast;

	public: // public interface
		
		int GetDeclNumber()const{return (int)m_mapDecl.size();}

		template<class T> 
		bool is()const
		{
			return typeid(T) == type();
		}

		template<class T> 
		bool is(T const& v)const{return is<T>()}

	public: // public interface
		bool creatable()const{return ClassFactory != 0;}

		bool applyeble()const
		{
			if(BaseOp.h_apply_obj != 0)return true;
			if(ParentType) return ParentType->applyeble();
			return false;
		}

		bool copyable()const{return BaseOp.h_copy_obj != 0;}
		bool comparable()const{return BaseOp.h_compare_obj != 0;}
		bool serializeble()const{return BaseOp.h_serial_save && BaseOp.h_serial_init;}	
		bool stringazeble()const{return BaseOp.h_to_str && BaseOp.h_from_str;}	

		bool can_save_to_string()const{return BaseOp.h_to_str !=0;}	
		bool can_init_from_string()const{return BaseOp.h_from_str !=0;}	
		bool can_init_from_filename()const{return BaseOp.h_from_filename !=0;}	
		
		char const* type_name()const{return czTypeName;} 
		std::type_info const& type(void)const{GSYS_ASSERT(TypeProc);return TypeProc();} 

		void* create_new()const
		{
			if(!ClassFactory) return 0;
			GSYS_ASSERT_CODE(ClassFactory);
			return ClassFactory(0);
		}
		bool delete_object(void* ptr)const
		{
			if(!ClassFactory) return 0;
			GSYS_ASSERT_CODE(ClassFactory);
			return ClassFactory(ptr) == 0;
		}

		virtual bool can_cast_to(vtid_t const * type)const
		{
			if(type != this)
			{
				StaticCastMap::const_iterator it =  m_mapCast.find(type);
				if(it != m_mapCast.end())return true;
				if(ParentType)return ParentType->can_cast_to(type);
				return false;
			}
			return true;
		}

		virtual void* cast_to(void* ptr,vtid_t const * type)const
		{
			if(type != this)
			{
				StaticCastMap::const_iterator it =  m_mapCast.find(type);
				if(it != m_mapCast.end())
				{
					return (gsys_byte*)ptr + it->second;
				}
				if(ParentType)
				{
					return ParentType->cast_to((gsys_byte*)ptr + iParentOffset,type);
				}
				return 0;
			}
			return ptr;
		}

		virtual void* cast_from(void* ptr,vtid_t const * type)const
		{
			if(type != this)
			{
				StaticCastMap::const_iterator it =  m_mapCast.find(type);
				if(it != m_mapCast.end())
				{
					return (gsys_byte*)ptr - it->second;
				}
				if(ParentType)
				{
					return ParentType->cast_from((gsys_byte*)ptr - iParentOffset,type);
				}
				return 0;
			}
			return ptr;
		}	
		vtid_t const* parent()const{return ParentType;}
	};
	typedef vtid_t const* vtid_typeinfo;
}

#endif